# DC motor control, encoder reading, and speed estimation

In this project, the speed of the DC motors were adjusted according to the proximity sensor's value. If no object is detected in front of the robot, the speed is high*. If an object is detected in front of the robot, the speed is reduced based on the proximity of the object, eventually stopping completely if the object is very close. The robot's LCD display shows the distance value (in mm) measured with the proximity sensor using the equation determined in Activity 2, along with the speed values (in mm/s) of each motor.

The motors are driven by PWM signals generated by the processing board, and the speed of each motor is estimated by the difference in encoder readings within a certain time interval.

Both channels of PWM from the PIC16F886 were used, where channel 1 controls the left motor, and channel 2 controls the right motor. Both were programmed to operate at the same frequency, with the pulse width controlling the motor speed. Each motor also has a bit for direction control.

For the speed calculation in mm/s, we considered the wheel diameter as 42 mm. 

**Please note that the maximum velocity should be, at maximum, a duty cycle of 60% for PWM.*

## Timer 0

The bits configure for the Timer 0 interruption are as it follows:

    void t0_init(void) {
        // Timer 0 is used for periodic interruption every approximately 5 ms    
	    OPTION_REGbits.T0CS = 0;  // Use internal clock FOSC/4
	    OPTION_REGbits.PSA = 0;   // Prescaler is for Timer 0 and not for WDT
	    OPTION_REGbits.PS = 7;    // Set Prescaler to 1:256
	    TMR0 = 0xff - 98;         // Initial value of Timer 0 for 5.0176 ms
	    TMR0IE = 1;               // Enable Timer 0 interruption
}

-  **OPTION\_REGbits.T0CS = 0**: Used to configure the pulse frequency. The chosen frequency was the internal one, meaning one-fourth of the oscillator frequency. Since the PIC model used in the laboratory operates at a frequency of 20 MHz, we have

$$  \dfrac{F_{osc}}{4} = \dfrac{20  \text{ MHz}}{4} = 5  \text{ MHz} $$ 

-  **OPTION\_REGbits.PSA = 0**: This parameter determines whether the prescaler will be used by the Watchdog Timer or Timer 0. With a value of $0$, the prescaler is reserved for Timer 0.

  
-  **OPTION\_REGbits.PS = 7**: Selection of the prescaler rate. With a value of $7$ (or 0b111), the rate is configured at $1:256$, meaning 256 pulses of \(F_{osc}/4\) for $1$ output pulse from the prescaler.


-  **TMR0 = 0xff - 98**: Initial value of Timer 0. In order to achieve the desired time between interruptions of $5$ ms, the overflow flag of Timer 0 must be activated after only $98$ pulses, instead of $255$. 

-  **TMR0IE = 1**: This parameter enables the Timer 0 interruption.

"The configuration above results in a Timer 0 interruption every 5.0176 ms, or approximately $5$ ms. In order to meet the velocity estimation requirement, the time base is set to 100 ms. Therefore,"

$$\dfrac{100  \text{ ms}}{5  \text{ ms}} = 20  \text{ interruptions}$$

So, every 20 interruptions, a measurement is performed.

## Period and Resolution of PWM

For each wheel revolution, there are 48 pulses. It has been determined that for the calculation of speed in mm/s, we should consider the wheel's diameter as 42 mm. Therefore, if we have the number of pulses in 100 ms, we just need to find the equivalent in mm/s. Note that 48 pulses correspond to 42 mm. Consider DIFF as the variable that holds the difference between the counters found in Timer 0.

$$\text{Distance }= \dfrac{42 \times \text{DIFF}}{48}$$

As these values are obtained every 100 ms, we have:

$$\text{Speed }= \dfrac{\text{Distance (mm)}}{\text{Time (s)}}$$

$$\text{Speed } = \dfrac{\text{Distance (mm)}}{0.1}$$

As for the desired period for the PR2 bit, it was consulted in the datasheet.

## PWM initialization and duty cycle alteration 

    void pwm_init(void) {
        TRISC2 = 1;  // Disable output (CCP1 - enhanced)
        TRISC1 = 1;  // Disable output (CCP2)
    
        // Calculation of the desired PWM period
        // Fosc = 20 MHz, Fpwm = 19.53 kHz, TMR2 pre-scaler -> 4
        PR2 = 255;
    
        // Configuration of PWM output
    
        // CCP1
        CCP1CONbits.CCP1M = 0b1100;
        CCP1CONbits.P1M = 0;  // Single output
    
        // CCP2 - does not have advanced functions, so CCP2M does not exist
        CCP2CONbits.CCP2M = 0b1100;
    
        // CCP1
        CCPR1L = 0;
    
        // Start PWM with duty cycle 0
        CCP1CONbits.DC1B = 0;
    
        // CCP2
        CCPR2L = 0;
    
        // TMR2 setup
        TMR2IF = 0;            // Clear TMR2 flag
        T2CONbits.T2CKPS = 0;  // Configure pre-scaler to 1:1
        TMR2ON = 1;            // Turn on TMR2
    
        while (!TMR2IF)
            ;  // Wait for TMR2 overflow to start PWM cycle
    
        TRISC2 = 0;  // Enable output (CCP1 - enhanced)
        TRISC1 = 0;  // Enable output (CCP2)
    }

  
The bits configured in this function are:

- **TRISC2**: controls pin C2 as an output (when TRISC2 = 0) or as an input (when TRISC2 = 1).

- **TRISC1**: same as TRISC2 for pin C1.

- **PR2**: alters the period or operating frequency of the timer.

- **CCP1CONbits.CCP1M**: activates PWM mode for module CCP1.

- **CCP1CONbits.P1M**: this parameter configures module CCP1 to have a single output.

- **CCP2CONbits.CCP2M**: configures the module in Capture mode to measure time.

- **CCPR1L**: stores the value of the duty cycle.

- **CCP1CONbits.DC1B**: sets the value for the duty cycle. In this case, setting it to 0 determines a LOW logic level.

- **CCPR2L**: analogous to CCPR1L.

- **TMR2IF**: this parameter clears the TMR2 flag.

- **T2CONbits.T2CKPS**: this parameter configures the pre-scaler of Timer 2 to 1:1.

- **TMR2ON**: enables Timer 2.

        void pwm_set(int channel, int duty_cycle) {
        
	        if (channel == 1) {            // CCP1
	            CCPR1L = duty_cycle >> 2;  // Shift the value to select only the
	                                       // 8 most significant bits
	        }
    
	        if (channel == 2) {            // CCP2
	            CCPR2L = duty_cycle >> 2;  // Shift the value to select only the
	                                       // 8 most significant bits
		    }
		}
	
The bits configured in this function have already been explained in the above-mentioned function. Here, only the values of the duty cycle are modified.